self.tasklets={},function(){function a(a){return a&&a[g]}function b(a){const{port1:b,port2:c}=new MessageChannel;return new h(a,b),{result:{__transfer_proxy_port:c},transferables:[c]}}function c(c){return a(c)?b(c):{result:c,transferables:f(c)}}function d(a){return a instanceof ArrayBuffer||a instanceof MessagePort}function*e(a){if('string'==typeof a)return a;if(a){const b=Object.values(a);yield*b;for(const a of b)yield*e(a)}}function f(a){return Array.from(e(a)).filter((a)=>d(a))}const g=Symbol('transferProxy');class h{constructor(a,b){this.object=a,this.port=b,this.port.onmessage=this.onmessage.bind(this),this.port.start()}async onmessage(a){const b=a.data.callPath;switch(a.data.type){case'GET':case'APPLY':{let d=await b.reduce((a,b)=>a[b],this.object);if('APPLY'===a.data.type){b.pop();const c=await b.reduce((a,b)=>a[b],this.object);d=await d.apply(c,a.data.argumentsList)}const{result:e,transferables:f}=c(d);this.port.postMessage({id:a.data.id,result:e},f);break}case'CONSTRUCT':{const c=b.reduce((a,b)=>a[b],this.object),d=new c(...a.data.argumentsList),{port1:e,port2:f}=new MessageChannel;new h(d,e),this.port.postMessage({id:a.data.id,result:{port:f}},[f]);break}}}}addEventListener('message',(a)=>{try{const b={};self.tasklets.export=(a,c='')=>{c||(c=a.name),b[c]=a},importScripts(a.data.path);const{port1:c,port2:d}=new MessageChannel;new h(b,c),delete self.tasklets.export,postMessage({id:a.data.id,port:d},[d])}catch(b){postMessage({id:a.data.id,error:b.toString(),stack:b.stack})}}),self.transferProxy=function(a){return a[g]=!0,a}}();
